// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen
// Distributed under the MIT License.
// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)

import * as fs from "fs";
import * as path from "path";

const COLUMN_LIMIT = 80;
const EOL = "\n";
const INDENT = 8;
const OUTPUT_DIR = path.resolve(__dirname, "..", "src", "Resources");

export function makeBanner(p: string): string {
  const script = path.basename(p).replace(/\.js$/, ".ts");
  return [
    `// This file was generated by \`${script}\`. DO NOT MODIFY!`,
    "//",
    "// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen",
    "// Distributed under the MIT License.",
    "// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)"
  ].join(EOL);
}

export function makeSafeName(filename: string): string {
  return filename.replace(/[^\w]/g, "_");
}

async function importAsset(asset: string): Promise<boolean> {
  if (!fs.existsSync(asset)) {
    console.warn(`No such file: ${asset}`);
    return false;
  }

  const stat = fs.statSync(asset);
  if (!stat.isFile()) {
    console.warn(`Not a file: ${asset}`);
    return false;
  }

  return new Promise<boolean>((resolve, reject) => {
    const filename = path.basename(asset);
    const name = makeSafeName(filename);
    const guard = name.toUpperCase();

    const header = path.join(OUTPUT_DIR, `${filename}.h`);
    const output = fs.createWriteStream(header, { mode: 0o644 });
    output.write(
      [
        makeBanner(__filename),
        "",
        `#ifndef RESOURCES_${guard}_H_`,
        `#define RESOURCES_${guard}_H_`,
        "",
        "// clang-format off",
        "",
        "namespace rainbow::assets",
        "{",
        `    constexpr uint8_t k${name}[]{`,
        " ".repeat(INDENT)
      ].join(EOL)
    );

    const newline = EOL + " ".repeat(INDENT);
    let cursor = INDENT;
    fs.createReadStream(asset)
      .on("data", (chunk: Buffer) => {
        chunk.forEach(byte => {
          const b = byte.toString();
          if (cursor + b.length >= COLUMN_LIMIT) {
            output.write(newline);
            cursor = INDENT;
          }
          const i = `${b},`;
          output.write(i);
          cursor += i.length;
        });
      })
      .on("end", () => {
        output.end(
          [
            "",
            "    };",
            "}  // namespace rainbow::assets",
            "",
            "// clang-format on",
            "",
            "#endif",
            ""
          ].join(EOL)
        );
        resolve(true);
        console.log(`${asset} -> ${header}`);
      })
      .on("error", (e: Error) => {
        output.destroy(e);
        reject(e.message);
      });
  });
}

if (!module.parent) {
  process.argv.slice(process.argv.indexOf(__filename) + 1).forEach(importAsset);
}
