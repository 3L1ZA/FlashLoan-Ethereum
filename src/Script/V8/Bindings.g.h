// This file was generated by `generate-bindings.ts`. DO NOT MODIFY!
//
// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen
// Distributed under the MIT License.
// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)

#ifndef SCRIPT_V8_BINDINGS_G_H_
#define SCRIPT_V8_BINDINGS_G_H_

// clang-format off

#include "Script/V8/BindingHelpers.h"

namespace rainbow::js
{
    [[nodiscard]] auto generate_bindings(v8::Local<v8::Context> context)
    {
        auto isolate = context->GetIsolate();
        v8::EscapableHandleScope handle_scope(isolate);

        auto rainbow = v8::Object::New(isolate);
        {
            constexpr MethodInfo ctor{
                nullptr,
                [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                    auto isolate = info.GetIsolate();
                    v8::HandleScope handle_scope(isolate);

                    if (!is_construct_call(
                            info, "TypeError: Animation is a constructor"))
                    {
                        return;
                    }

                    auto context = isolate->GetCurrentContext();
                    auto sprite = unwrap<SpriteRef>(context, info[0]);
                    auto frames = unwrap<Animation::Frames>(context, info[1]);
                    auto fps = unwrap<uint32_t>(context, info[2]);
                    auto delay = unwrap<int>(context, info[3]);
                    auto ptr = make<Animation>(sprite, frames, fps, delay);
                    set_reference(info.Holder(), ptr);
                },
                4,
            };
            constexpr MethodInfo methods[]{
                {
                    "current_frame",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Animation>(info.Holder());
                        info.GetReturnValue().Set(self->current_frame());
                    },
                    0,
                },
                {
                    "frame_rate",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Animation>(info.Holder());
                        info.GetReturnValue().Set(self->frame_rate());
                    },
                    0,
                },
                {
                    "sprite",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Animation>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->sprite()));
                    },
                    0,
                },
                {
                    "set_callback",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto callback = unwrap<Animation::Callback>(context, info[0]);
                        auto self = get_reference<Animation>(info.Holder());
                        self->set_callback(callback);
                    },
                    1,
                },
                {
                    "set_delay",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto delay = unwrap<int>(context, info[0]);
                        auto self = get_reference<Animation>(info.Holder());
                        self->set_delay(delay);
                    },
                    1,
                },
                {
                    "set_frame_rate",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto fps = unwrap<uint32_t>(context, info[0]);
                        auto self = get_reference<Animation>(info.Holder());
                        self->set_frame_rate(fps);
                    },
                    1,
                },
                {
                    "set_frames",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto frames = unwrap<Animation::Frames>(context, info[0]);
                        auto self = get_reference<Animation>(info.Holder());
                        self->set_frames(frames);
                    },
                    1,
                },
                {
                    "set_sprite",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto sprite = unwrap<SpriteRef>(context, info[0]);
                        auto self = get_reference<Animation>(info.Holder());
                        self->set_sprite(sprite);
                    },
                    1,
                },
                {
                    "jump_to",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto frame = unwrap<uint32_t>(context, info[0]);
                        auto self = get_reference<Animation>(info.Holder());
                        self->jump_to(frame);
                    },
                    1,
                },
                {
                    "rewind",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Animation>(info.Holder());
                        self->rewind();
                    },
                    0,
                },
                {
                    "start",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Animation>(info.Holder());
                        self->start();
                    },
                    0,
                },
                {
                    "stop",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Animation>(info.Holder());
                        self->stop();
                    },
                    0,
                },
            };
            auto module = define_class(context, "Animation", ctor, 1, methods);
            set_module(context, rainbow, "Animation", module);
        }
        {
            constexpr EnumValue values[]{
                {"Start", 0},
                {"End", 1},
                {"Complete", 2},
                {"Frame", 3},
            };
            auto module = define_enum(context, values);
            set_module(context, rainbow, "AnimationEvent", module);
        }
        {
            constexpr EnumValue values[]{
                {"Invalid", -1},
                {"LeftX", 0},
                {"LeftY", 1},
                {"RightX", 2},
                {"RightY", 3},
                {"TriggerLeft", 4},
                {"TriggerRight", 5},
                {"Count", 6},
            };
            auto module = define_enum(context, values);
            set_module(context, rainbow, "ControllerAxis", module);
        }
        {
            constexpr EnumValue values[]{
                {"Invalid", -1},
                {"A", 0},
                {"B", 1},
                {"X", 2},
                {"Y", 3},
                {"Back", 4},
                {"Guide", 5},
                {"Start", 6},
                {"LeftStick", 7},
                {"RightStick", 8},
                {"LeftShoulder", 9},
                {"RightShoulder", 10},
                {"DPadUp", 11},
                {"DPadDown", 12},
                {"DPadLeft", 13},
                {"DPadRight", 14},
                {"Count", 15},
            };
            auto module = define_enum(context, values);
            set_module(context, rainbow, "ControllerButton", module);
        }
        {
            constexpr MethodInfo ctor{
                nullptr,
                [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                    auto isolate = info.GetIsolate();
                    v8::HandleScope handle_scope(isolate);

                    if (!is_construct_call(
                            info, "TypeError: Label is a constructor"))
                    {
                        return;
                    }

                    auto ptr = make<Label>();
                    set_reference(info.Holder(), ptr);
                },
                0,
            };
            constexpr MethodInfo methods[]{
                {
                    "alignment",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(to_underlying_type(self->alignment()));
                    },
                    0,
                },
                {
                    "angle",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(self->angle());
                    },
                    0,
                },
                {
                    "color",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->color()));
                    },
                    0,
                },
                {
                    "height",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(self->height());
                    },
                    0,
                },
                {
                    "length",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(self->length());
                    },
                    0,
                },
                {
                    "position",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->position()));
                    },
                    0,
                },
                {
                    "scale",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(self->scale());
                    },
                    0,
                },
                {
                    "text",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(
                            v8::String::NewFromUtf8(isolate,
                                                    self->text(),
                                                    v8::NewStringType::kNormal)
                                .ToLocalChecked());
                    },
                    0,
                },
                {
                    "width",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<Label>(info.Holder());
                        info.GetReturnValue().Set(self->width());
                    },
                    0,
                },
                {
                    "set_alignment",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto alignment = unwrap<TextAlignment>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->set_alignment(alignment);
                    },
                    1,
                },
                {
                    "set_color",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto color = unwrap<Color>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->set_color(color);
                    },
                    1,
                },
                {
                    "set_font",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto font = unwrap<czstring>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->set_font(font);
                    },
                    1,
                },
                {
                    "set_font_size",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto fontSize = unwrap<int>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->set_font_size(fontSize);
                    },
                    1,
                },
                {
                    "set_position",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto position = unwrap<Vec2f>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->set_position(position);
                    },
                    1,
                },
                {
                    "set_rotation",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto r = unwrap<float>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->set_rotation(r);
                    },
                    1,
                },
                {
                    "set_scale",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto factor = unwrap<float>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->set_scale(factor);
                    },
                    1,
                },
                {
                    "set_text",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto text = unwrap<czstring>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->set_text(text);
                    },
                    1,
                },
                {
                    "move",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto delta = unwrap<Vec2f>(context, info[0]);
                        auto self = get_reference<Label>(info.Holder());
                        self->move(delta);
                    },
                    1,
                },
            };
            auto module = define_class(context, "Label", ctor, 1, methods);
            set_module(context, rainbow, "Label", module);
        }
        {
            constexpr MethodInfo ctor{};
            constexpr MethodInfo methods[]{
                {
                    "angle",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(self->angle());
                    },
                    0,
                },
                {
                    "color",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->color()));
                    },
                    0,
                },
                {
                    "height",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(self->height());
                    },
                    0,
                },
                {
                    "id",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(self->id());
                    },
                    0,
                },
                {
                    "is_flipped",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(self->is_flipped());
                    },
                    0,
                },
                {
                    "is_hidden",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(self->is_hidden());
                    },
                    0,
                },
                {
                    "is_mirrored",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(self->is_mirrored());
                    },
                    0,
                },
                {
                    "pivot",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->pivot()));
                    },
                    0,
                },
                {
                    "position",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->position()));
                    },
                    0,
                },
                {
                    "scale",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->scale()));
                    },
                    0,
                },
                {
                    "width",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        info.GetReturnValue().Set(self->width());
                    },
                    0,
                },
                {
                    "set_color",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto color = unwrap<Color>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->set_color(color);
                    },
                    1,
                },
                {
                    "set_id",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto id = unwrap<int>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->set_id(id);
                    },
                    1,
                },
                {
                    "set_normal",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto id = unwrap<uint32_t>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->set_normal(id);
                    },
                    1,
                },
                {
                    "set_pivot",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto pivot = unwrap<Vec2f>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->set_pivot(pivot);
                    },
                    1,
                },
                {
                    "set_position",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto position = unwrap<Vec2f>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->set_position(position);
                    },
                    1,
                },
                {
                    "set_rotation",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto r = unwrap<float>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->set_rotation(r);
                    },
                    1,
                },
                {
                    "set_scale",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto factor = unwrap<Vec2f>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->set_scale(factor);
                    },
                    1,
                },
                {
                    "set_texture",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto id = unwrap<uint32_t>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->set_texture(id);
                    },
                    1,
                },
                {
                    "flip",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->flip();
                    },
                    0,
                },
                {
                    "hide",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->hide();
                    },
                    0,
                },
                {
                    "mirror",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->mirror();
                    },
                    0,
                },
                {
                    "move",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto dt = unwrap<Vec2f>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->move(dt);
                    },
                    1,
                },
                {
                    "rotate",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto r = unwrap<float>(context, info[0]);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->rotate(r);
                    },
                    1,
                },
                {
                    "show",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteRef>(info.Holder());
                        self->show();
                    },
                    0,
                },
            };
            auto module = define_class(context, "Sprite", ctor, 2, methods);
            set_module(context, rainbow, "Sprite", module);
        }
        {
            constexpr MethodInfo ctor{
                nullptr,
                [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                    auto isolate = info.GetIsolate();
                    v8::HandleScope handle_scope(isolate);

                    if (!is_construct_call(
                            info, "TypeError: SpriteBatch is a constructor"))
                    {
                        return;
                    }

                    auto context = isolate->GetCurrentContext();
                    auto count = unwrap<uint32_t>(context, info[0]);
                    auto ptr = make<SpriteBatch>(count);
                    set_reference(info.Holder(), ptr);
                },
                1,
            };
            constexpr MethodInfo methods[]{
                {
                    "is_visible",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        info.GetReturnValue().Set(self->is_visible());
                    },
                    0,
                },
                {
                    "set_normal",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto texture = unwrap<SharedPtr<TextureAtlas>>(context, info[0]);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        self->set_normal(texture);
                    },
                    1,
                },
                {
                    "set_texture",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto texture = unwrap<SharedPtr<TextureAtlas>>(context, info[0]);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        self->set_texture(texture);
                    },
                    1,
                },
                {
                    "set_visible",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto visible = unwrap<bool>(context, info[0]);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        self->set_visible(visible);
                    },
                    1,
                },
                {
                    "clear",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        self->clear();
                    },
                    0,
                },
                {
                    "create_sprite",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto width = unwrap<uint32_t>(context, info[0]);
                        auto height = unwrap<uint32_t>(context, info[1]);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->create_sprite(width, height)));
                    },
                    2,
                },
                {
                    "erase",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto i = unwrap<uint32_t>(context, info[0]);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        self->erase(i);
                    },
                    1,
                },
                {
                    "find_sprite_by_id",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto id = unwrap<int>(context, info[0]);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        info.GetReturnValue().Set(wrap(isolate, self->find_sprite_by_id(id)));
                    },
                    1,
                },
                {
                    "swap",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto a = unwrap<SpriteRef>(context, info[0]);
                        auto b = unwrap<SpriteRef>(context, info[1]);
                        auto self = get_reference<SpriteBatch>(info.Holder());
                        self->swap(a, b);
                    },
                    2,
                },
            };
            auto module = define_class(context, "SpriteBatch", ctor, 1, methods);
            set_module(context, rainbow, "SpriteBatch", module);
        }
        {
            constexpr EnumValue values[]{
                {"Left", 0},
                {"Right", 1},
                {"Center", 2},
            };
            auto module = define_enum(context, values);
            set_module(context, rainbow, "TextAlignment", module);
        }
        {
            constexpr MethodInfo ctor{
                nullptr,
                [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                    auto isolate = info.GetIsolate();
                    v8::HandleScope handle_scope(isolate);

                    if (!is_construct_call(
                            info, "TypeError: Texture is a constructor"))
                    {
                        return;
                    }

                    auto context = isolate->GetCurrentContext();
                    auto path = unwrap<czstring>(context, info[0]);
                    auto ptr = make<TextureAtlas>(path);
                    set_reference(info.Holder(), ptr);
                },
                1,
            };
            constexpr MethodInfo methods[]{
                {
                    "add_region",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto context = isolate->GetCurrentContext();
                        auto x = unwrap<int>(context, info[0]);
                        auto y = unwrap<int>(context, info[1]);
                        auto width = unwrap<int>(context, info[2]);
                        auto height = unwrap<int>(context, info[3]);
                        auto self = get_reference<TextureAtlas>(info.Holder());
                        info.GetReturnValue().Set(self->add_region(x, y, width, height));
                    },
                    4,
                },
                {
                    "trim",
                    [](const v8::FunctionCallbackInfo<v8::Value>& info) {
                        auto isolate = info.GetIsolate();
                        v8::HandleScope handle_scope(isolate);
                        auto self = get_reference<TextureAtlas>(info.Holder());
                        self->trim();
                    },
                    0,
                },
            };
            auto module = define_class(context, "Texture", ctor, 1, methods);
            set_module(context, rainbow, "Texture", module);
        }
        {
            constexpr EnumValue values[]{
                {"Unknown", 0},
                {"A", 1},
                {"B", 2},
                {"C", 3},
                {"D", 4},
                {"E", 5},
                {"F", 6},
                {"G", 7},
                {"H", 8},
                {"I", 9},
                {"J", 10},
                {"K", 11},
                {"L", 12},
                {"M", 13},
                {"N", 14},
                {"O", 15},
                {"P", 16},
                {"Q", 17},
                {"R", 18},
                {"S", 19},
                {"T", 20},
                {"U", 21},
                {"V", 22},
                {"W", 23},
                {"X", 24},
                {"Y", 25},
                {"Z", 26},
                {"Number1", 27},
                {"Number2", 28},
                {"Number3", 29},
                {"Number4", 30},
                {"Number5", 31},
                {"Number6", 32},
                {"Number7", 33},
                {"Number8", 34},
                {"Number9", 35},
                {"Number0", 36},
                {"Return", 37},
                {"Escape", 38},
                {"Backspace", 39},
                {"Tab", 40},
                {"Space", 41},
                {"Minus", 42},
                {"Equals", 43},
                {"LeftBracket", 44},
                {"RightBracket", 45},
                {"Backslash", 46},
                {"Semicolon", 47},
                {"Apostrophe", 48},
                {"Grave", 49},
                {"Comma", 50},
                {"Period", 51},
                {"Slash", 52},
                {"CapsLock", 53},
                {"F1", 54},
                {"F2", 55},
                {"F3", 56},
                {"F4", 57},
                {"F5", 58},
                {"F6", 59},
                {"F7", 60},
                {"F8", 61},
                {"F9", 62},
                {"F10", 63},
                {"F11", 64},
                {"F12", 65},
                {"PrintScreen", 66},
                {"ScrollLock", 67},
                {"Pause", 68},
                {"Insert", 69},
                {"Home", 70},
                {"PageUp", 71},
                {"Delete", 72},
                {"End", 73},
                {"PageDown", 74},
                {"Right", 75},
                {"Left", 76},
                {"Down", 77},
                {"Up", 78},
                {"NumLock", 79},
                {"KP_Divide", 80},
                {"KP_Multiply", 81},
                {"KP_Minus", 82},
                {"KP_Plus", 83},
                {"KP_Enter", 84},
                {"KP_1", 85},
                {"KP_2", 86},
                {"KP_3", 87},
                {"KP_4", 88},
                {"KP_5", 89},
                {"KP_6", 90},
                {"KP_7", 91},
                {"KP_8", 92},
                {"KP_9", 93},
                {"KP_0", 94},
                {"KP_Period", 95},
                {"LessThan", 96},
                {"Application", 97},
                {"Power", 98},
                {"KP_Equals", 99},
                {"F13", 100},
                {"F14", 101},
                {"F15", 102},
                {"F16", 103},
                {"F17", 104},
                {"F18", 105},
                {"F19", 106},
                {"F20", 107},
                {"F21", 108},
                {"F22", 109},
                {"F23", 110},
                {"F24", 111},
                {"LeftCtrl", 112},
                {"LeftShift", 113},
                {"LeftAlt", 114},
                {"LeftSuper", 115},
                {"RightCtrl", 116},
                {"RightShift", 117},
                {"RightAlt", 118},
                {"RightSuper", 119},
                {"Mode", 120},
                {"KeyCount", 121},
            };
            auto module = define_enum(context, values);
            set_module(context, rainbow, "VirtualKey", module);
        }

        rainbow->SetIntegrityLevel(context, v8::IntegrityLevel::kFrozen);
        return handle_scope.Escape(rainbow);
    }
}  // namespace rainbow::js

// clang-format on

#endif
