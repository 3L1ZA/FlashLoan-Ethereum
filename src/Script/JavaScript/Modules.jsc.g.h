// This file was generated by `tools/generate-bindings.ts`. DO NOT MODIFY!
//
// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen
// Distributed under the MIT License.
// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)

#ifndef SCRIPT_JAVASCRIPT_MODULES_JSC_G_H_
#define SCRIPT_JAVASCRIPT_MODULES_JSC_G_H_

#include "Script/JavaScript/Helper.jsc.h"

// clang-format off

#define JS_MAKE_ENUM_VALUE(enum, value)                                        \
    {                                                                          \
        #value,                                                                \
        [](JSContextRef ctx, JSObjectRef, JSStringRef, JSValueRef*) {          \
            return JSValueMakeNumber(ctx, to_integral_value(enum::value));     \
        },                                                                     \
        nullptr,                                                               \
        kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontDelete          \
    }

#define JS_MAKE_FUNCTION(name, func)                                           \
    {                                                                          \
        #name, []([[maybe_unused]] JSContextRef ctx,                           \
                  JSObjectRef,                                                 \
                  JSObjectRef object,                                          \
                  [[maybe_unused]] size_t argc,                                \
                  [[maybe_unused]] const JSValueRef argv[],                    \
                  JSValueRef*) func,                                           \
                kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontEnum |  \
                    kJSPropertyAttributeDontDelete                             \
    }

#define JS_SET_CONSTRUCTOR(ctx, module, name, prefix)                          \
    JSObjectSetProperty(                                                       \
        ctx,                                                                   \
        module,                                                                \
        UniqueStringRef(#name),                                                \
        JSObjectMakeConstructor(ctx,                                           \
                                UniqueClassRef(&prefix##_definition),          \
                                prefix##_definition.callAsConstructor),        \
        kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontDelete,         \
        nullptr)

#define JS_SET_ENUM(ctx, module, name, prefix)                                 \
    JSObjectSetProperty(                                                       \
        ctx,                                                                   \
        module,                                                                \
        UniqueStringRef(#name),                                                \
        JSObjectMake(ctx, UniqueClassRef(&prefix##_definition), nullptr),      \
        kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontDelete,         \
        nullptr)

auto rainbow::jsc::register_all(JSGlobalContextRef global_context) -> JSObjectRef
{
    static const JSStaticFunction animation_static_functions[]{
        JS_MAKE_FUNCTION(currentFrame, {
            R_ASSERT(argc == 0, "Rainbow.Animation.prototype.currentFrame: Expected 0 arguments");
            auto self = get_instance<Animation>(object);
            auto ret = self->current_frame();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(frameRate, {
            R_ASSERT(argc == 0, "Rainbow.Animation.prototype.frameRate: Expected 0 arguments");
            auto self = get_instance<Animation>(object);
            auto ret = self->frame_rate();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(sprite, {
            R_ASSERT(argc == 0, "Rainbow.Animation.prototype.sprite: Expected 0 arguments");
            auto self = get_instance<Animation>(object);
            auto ret = self->sprite();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(setCallback, {
            R_ASSERT(argc == 1, "Rainbow.Animation.prototype.setCallback: Expected 1 argument");
            auto self = get_instance<Animation>(object);
            self->set_callback(value_to<Animation::Callback>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setDelay, {
            R_ASSERT(argc == 1, "Rainbow.Animation.prototype.setDelay: Expected 1 argument");
            auto self = get_instance<Animation>(object);
            self->set_delay(value_to<int>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setFrameRate, {
            R_ASSERT(argc == 1, "Rainbow.Animation.prototype.setFrameRate: Expected 1 argument");
            auto self = get_instance<Animation>(object);
            self->set_frame_rate(value_to<uint32_t>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setFrames, {
            R_ASSERT(argc == 1, "Rainbow.Animation.prototype.setFrames: Expected 1 argument");
            auto self = get_instance<Animation>(object);
            self->set_frames(value_to<Animation::Frames>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setSprite, {
            R_ASSERT(argc == 1, "Rainbow.Animation.prototype.setSprite: Expected 1 argument");
            auto self = get_instance<Animation>(object);
            self->set_sprite(value_to<SpriteRef>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(jumpTo, {
            R_ASSERT(argc == 1, "Rainbow.Animation.prototype.jumpTo: Expected 1 argument");
            auto self = get_instance<Animation>(object);
            self->jump_to(value_to<uint32_t>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(rewind, {
            R_ASSERT(argc == 0, "Rainbow.Animation.prototype.rewind: Expected 0 arguments");
            auto self = get_instance<Animation>(object);
            self->rewind();
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(start, {
            R_ASSERT(argc == 0, "Rainbow.Animation.prototype.start: Expected 0 arguments");
            auto self = get_instance<Animation>(object);
            self->start();
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(stop, {
            R_ASSERT(argc == 0, "Rainbow.Animation.prototype.stop: Expected 0 arguments");
            auto self = get_instance<Animation>(object);
            self->stop();
            return make_value(ctx, nullptr);
        }),
        {nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition animation_definition = create_class_definition(
        "Animation",
        nullptr,
        animation_static_functions,
        [](JSObjectRef object) {
            delete static_cast<Animation*>(JSObjectGetPrivate(object));
        },
        []([[maybe_unused]] JSContextRef ctx,
           [[maybe_unused]] JSObjectRef constructor,
           [[maybe_unused]] size_t argc,
           [[maybe_unused]] const JSValueRef argv[],
           JSValueRef*) {
            R_ASSERT(argc == 4, "Rainbow.Animation: Expected 4 arguments");
            JSObjectSetPrivate(
                constructor,
                std::make_unique<Animation>(
                    value_to<SpriteRef>(ctx, argv[0]),
                    value_to<Animation::Frames>(ctx, argv[1]),
                    value_to<uint32_t>(ctx, argv[2]),
                    value_to<int>(ctx, argv[3]))
                    .release());
            return constructor;
        }
    );

    static const JSStaticValue animationevent_static_values[]{
        JS_MAKE_ENUM_VALUE(AnimationEvent, Start),
        JS_MAKE_ENUM_VALUE(AnimationEvent, End),
        JS_MAKE_ENUM_VALUE(AnimationEvent, Complete),
        JS_MAKE_ENUM_VALUE(AnimationEvent, Frame),
        {nullptr, nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition animationevent_definition = create_class_definition(
        "AnimationEvent",
        animationevent_static_values,
        nullptr,
        nullptr,
        nullptr
    );

    static const JSStaticValue controlleraxis_static_values[]{
        JS_MAKE_ENUM_VALUE(ControllerAxis, Invalid),
        JS_MAKE_ENUM_VALUE(ControllerAxis, LeftX),
        JS_MAKE_ENUM_VALUE(ControllerAxis, LeftY),
        JS_MAKE_ENUM_VALUE(ControllerAxis, RightX),
        JS_MAKE_ENUM_VALUE(ControllerAxis, RightY),
        JS_MAKE_ENUM_VALUE(ControllerAxis, TriggerLeft),
        JS_MAKE_ENUM_VALUE(ControllerAxis, TriggerRight),
        JS_MAKE_ENUM_VALUE(ControllerAxis, Count),
        {nullptr, nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition controlleraxis_definition = create_class_definition(
        "ControllerAxis",
        controlleraxis_static_values,
        nullptr,
        nullptr,
        nullptr
    );

    static const JSStaticValue controllerbutton_static_values[]{
        JS_MAKE_ENUM_VALUE(ControllerButton, Invalid),
        JS_MAKE_ENUM_VALUE(ControllerButton, A),
        JS_MAKE_ENUM_VALUE(ControllerButton, B),
        JS_MAKE_ENUM_VALUE(ControllerButton, X),
        JS_MAKE_ENUM_VALUE(ControllerButton, Y),
        JS_MAKE_ENUM_VALUE(ControllerButton, Back),
        JS_MAKE_ENUM_VALUE(ControllerButton, Guide),
        JS_MAKE_ENUM_VALUE(ControllerButton, Start),
        JS_MAKE_ENUM_VALUE(ControllerButton, LeftStick),
        JS_MAKE_ENUM_VALUE(ControllerButton, RightStick),
        JS_MAKE_ENUM_VALUE(ControllerButton, LeftShoulder),
        JS_MAKE_ENUM_VALUE(ControllerButton, RightShoulder),
        JS_MAKE_ENUM_VALUE(ControllerButton, DPadUp),
        JS_MAKE_ENUM_VALUE(ControllerButton, DPadDown),
        JS_MAKE_ENUM_VALUE(ControllerButton, DPadLeft),
        JS_MAKE_ENUM_VALUE(ControllerButton, DPadRight),
        JS_MAKE_ENUM_VALUE(ControllerButton, Count),
        {nullptr, nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition controllerbutton_definition = create_class_definition(
        "ControllerButton",
        controllerbutton_static_values,
        nullptr,
        nullptr,
        nullptr
    );

    static const JSStaticFunction label_static_functions[]{
        JS_MAKE_FUNCTION(alignment, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.alignment: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->alignment();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(angle, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.angle: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->angle();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(color, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.color: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->color();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(height, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.height: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->height();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(length, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.length: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->length();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(position, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.position: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->position();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(scale, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.scale: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->scale();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(text, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.text: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->text();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(width, {
            R_ASSERT(argc == 0, "Rainbow.Label.prototype.width: Expected 0 arguments");
            auto self = get_instance<Label>(object);
            auto ret = self->width();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(setAlignment, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.setAlignment: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->set_alignment(value_to<TextAlignment>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setColor, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.setColor: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->set_color(value_to<Color>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setFont, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.setFont: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->set_font(value_to<czstring>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setFontSize, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.setFontSize: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->set_font_size(value_to<int>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setPosition, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.setPosition: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->set_position(value_to<Vec2f>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setRotation, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.setRotation: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->set_rotation(value_to<float>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setScale, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.setScale: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->set_scale(value_to<float>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setText, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.setText: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->set_text(value_to<czstring>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(move, {
            R_ASSERT(argc == 1, "Rainbow.Label.prototype.move: Expected 1 argument");
            auto self = get_instance<Label>(object);
            self->move(value_to<Vec2f>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        {nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition label_definition = create_class_definition(
        "Label",
        nullptr,
        label_static_functions,
        [](JSObjectRef object) {
            delete static_cast<Label*>(JSObjectGetPrivate(object));
        },
        []([[maybe_unused]] JSContextRef ctx,
           [[maybe_unused]] JSObjectRef constructor,
           [[maybe_unused]] size_t argc,
           [[maybe_unused]] const JSValueRef argv[],
           JSValueRef*) {
            R_ASSERT(argc == 0, "Rainbow.Label: Expected 0 arguments");
            JSObjectSetPrivate(
                constructor,
                std::make_unique<Label>().release());
            return constructor;
        }
    );

    static const JSStaticFunction sprite_static_functions[]{
        JS_MAKE_FUNCTION(angle, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.angle: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->angle();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(color, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.color: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->color();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(height, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.height: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->height();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(id, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.id: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->id();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(isFlipped, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.isFlipped: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->is_flipped();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(isHidden, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.isHidden: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->is_hidden();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(isMirrored, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.isMirrored: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->is_mirrored();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(pivot, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.pivot: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->pivot();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(position, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.position: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->position();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(scale, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.scale: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->scale();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(width, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.width: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            auto ret = self->width();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(setColor, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.setColor: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->set_color(value_to<Color>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setId, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.setId: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->set_id(value_to<int>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setNormal, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.setNormal: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->set_normal(value_to<uint32_t>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setPivot, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.setPivot: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->set_pivot(value_to<Vec2f>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setPosition, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.setPosition: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->set_position(value_to<Vec2f>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setRotation, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.setRotation: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->set_rotation(value_to<float>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setScale, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.setScale: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->set_scale(value_to<Vec2f>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setTexture, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.setTexture: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->set_texture(value_to<uint32_t>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(flip, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.flip: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            self->flip();
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(hide, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.hide: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            self->hide();
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(mirror, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.mirror: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            self->mirror();
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(move, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.move: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->move(value_to<Vec2f>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(rotate, {
            R_ASSERT(argc == 1, "Rainbow.Sprite.prototype.rotate: Expected 1 argument");
            auto self = get_instance<SpriteRef>(object);
            self->rotate(value_to<float>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(show, {
            R_ASSERT(argc == 0, "Rainbow.Sprite.prototype.show: Expected 0 arguments");
            auto self = get_instance<SpriteRef>(object);
            self->show();
            return make_value(ctx, nullptr);
        }),
        {nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition sprite_definition = create_class_definition(
        "Sprite",
        nullptr,
        sprite_static_functions,
        [](JSObjectRef object) {
            delete static_cast<SpriteRef*>(JSObjectGetPrivate(object));
        },
        nullptr
    );

    static const JSStaticFunction spritebatch_static_functions[]{
        JS_MAKE_FUNCTION(isVisible, {
            R_ASSERT(argc == 0, "Rainbow.SpriteBatch.prototype.isVisible: Expected 0 arguments");
            auto self = get_instance<SpriteBatch>(object);
            auto ret = self->is_visible();
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(setNormal, {
            R_ASSERT(argc == 1, "Rainbow.SpriteBatch.prototype.setNormal: Expected 1 argument");
            auto self = get_instance<SpriteBatch>(object);
            self->set_normal(value_to<SharedPtr<TextureAtlas>>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setTexture, {
            R_ASSERT(argc == 1, "Rainbow.SpriteBatch.prototype.setTexture: Expected 1 argument");
            auto self = get_instance<SpriteBatch>(object);
            self->set_texture(value_to<SharedPtr<TextureAtlas>>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(setVisible, {
            R_ASSERT(argc == 1, "Rainbow.SpriteBatch.prototype.setVisible: Expected 1 argument");
            auto self = get_instance<SpriteBatch>(object);
            self->set_visible(value_to<bool>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(clear, {
            R_ASSERT(argc == 0, "Rainbow.SpriteBatch.prototype.clear: Expected 0 arguments");
            auto self = get_instance<SpriteBatch>(object);
            self->clear();
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(createSprite, {
            R_ASSERT(argc == 2, "Rainbow.SpriteBatch.prototype.createSprite: Expected 2 arguments");
            auto self = get_instance<SpriteBatch>(object);
            auto ret = self->create_sprite(
                value_to<uint32_t>(ctx, argv[0]),
                value_to<uint32_t>(ctx, argv[1]));
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(erase, {
            R_ASSERT(argc == 1, "Rainbow.SpriteBatch.prototype.erase: Expected 1 argument");
            auto self = get_instance<SpriteBatch>(object);
            self->erase(value_to<uint32_t>(ctx, argv[0]));
            return make_value(ctx, nullptr);
        }),
        JS_MAKE_FUNCTION(findSpriteById, {
            R_ASSERT(argc == 1, "Rainbow.SpriteBatch.prototype.findSpriteById: Expected 1 argument");
            auto self = get_instance<SpriteBatch>(object);
            auto ret = self->find_sprite_by_id(value_to<int>(ctx, argv[0]));
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(swap, {
            R_ASSERT(argc == 2, "Rainbow.SpriteBatch.prototype.swap: Expected 2 arguments");
            auto self = get_instance<SpriteBatch>(object);
            self->swap(
                value_to<SpriteRef>(ctx, argv[0]),
                value_to<SpriteRef>(ctx, argv[1]));
            return make_value(ctx, nullptr);
        }),
        {nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition spritebatch_definition = create_class_definition(
        "SpriteBatch",
        nullptr,
        spritebatch_static_functions,
        [](JSObjectRef object) {
            delete static_cast<SpriteBatch*>(JSObjectGetPrivate(object));
        },
        []([[maybe_unused]] JSContextRef ctx,
           [[maybe_unused]] JSObjectRef constructor,
           [[maybe_unused]] size_t argc,
           [[maybe_unused]] const JSValueRef argv[],
           JSValueRef*) {
            R_ASSERT(argc == 1, "Rainbow.SpriteBatch: Expected 1 argument");
            JSObjectSetPrivate(
                constructor,
                std::make_unique<SpriteBatch>(
                    value_to<uint32_t>(ctx, argv[0]))
                    .release());
            return constructor;
        }
    );

    static const JSStaticValue textalignment_static_values[]{
        JS_MAKE_ENUM_VALUE(TextAlignment, Left),
        JS_MAKE_ENUM_VALUE(TextAlignment, Right),
        JS_MAKE_ENUM_VALUE(TextAlignment, Center),
        {nullptr, nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition textalignment_definition = create_class_definition(
        "TextAlignment",
        textalignment_static_values,
        nullptr,
        nullptr,
        nullptr
    );

    static const JSStaticFunction texture_static_functions[]{
        JS_MAKE_FUNCTION(addRegion, {
            R_ASSERT(argc == 4, "Rainbow.Texture.prototype.addRegion: Expected 4 arguments");
            auto self = get_instance<SharedPtr<rainbow::TextureAtlas>>(object);
            auto ret = self->add_region(
                value_to<int>(ctx, argv[0]),
                value_to<int>(ctx, argv[1]),
                value_to<int>(ctx, argv[2]),
                value_to<int>(ctx, argv[3]));
            return make_value(ctx, ret);
        }),
        JS_MAKE_FUNCTION(trim, {
            R_ASSERT(argc == 0, "Rainbow.Texture.prototype.trim: Expected 0 arguments");
            auto self = get_instance<SharedPtr<rainbow::TextureAtlas>>(object);
            self->trim();
            return make_value(ctx, nullptr);
        }),
        {nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition texture_definition = create_class_definition(
        "Texture",
        nullptr,
        texture_static_functions,
        [](JSObjectRef object) {
            SharedPtr<rainbow::TextureAtlas>(static_cast<rainbow::TextureAtlas*>(JSObjectGetPrivate(object)));
        },
        []([[maybe_unused]] JSContextRef ctx,
           [[maybe_unused]] JSObjectRef constructor,
           [[maybe_unused]] size_t argc,
           [[maybe_unused]] const JSValueRef argv[],
           JSValueRef*) {
            R_ASSERT(argc == 1, "Rainbow.Texture: Expected 1 argument");
            JSObjectSetPrivate(
                constructor,
                std::make_unique<rainbow::TextureAtlas>(
                    value_to<czstring>(ctx, argv[0]))
                    .release());
            return constructor;
        }
    );

    static const JSStaticValue virtualkey_static_values[]{
        JS_MAKE_ENUM_VALUE(VirtualKey, Unknown),
        JS_MAKE_ENUM_VALUE(VirtualKey, A),
        JS_MAKE_ENUM_VALUE(VirtualKey, B),
        JS_MAKE_ENUM_VALUE(VirtualKey, C),
        JS_MAKE_ENUM_VALUE(VirtualKey, D),
        JS_MAKE_ENUM_VALUE(VirtualKey, E),
        JS_MAKE_ENUM_VALUE(VirtualKey, F),
        JS_MAKE_ENUM_VALUE(VirtualKey, G),
        JS_MAKE_ENUM_VALUE(VirtualKey, H),
        JS_MAKE_ENUM_VALUE(VirtualKey, I),
        JS_MAKE_ENUM_VALUE(VirtualKey, J),
        JS_MAKE_ENUM_VALUE(VirtualKey, K),
        JS_MAKE_ENUM_VALUE(VirtualKey, L),
        JS_MAKE_ENUM_VALUE(VirtualKey, M),
        JS_MAKE_ENUM_VALUE(VirtualKey, N),
        JS_MAKE_ENUM_VALUE(VirtualKey, O),
        JS_MAKE_ENUM_VALUE(VirtualKey, P),
        JS_MAKE_ENUM_VALUE(VirtualKey, Q),
        JS_MAKE_ENUM_VALUE(VirtualKey, R),
        JS_MAKE_ENUM_VALUE(VirtualKey, S),
        JS_MAKE_ENUM_VALUE(VirtualKey, T),
        JS_MAKE_ENUM_VALUE(VirtualKey, U),
        JS_MAKE_ENUM_VALUE(VirtualKey, V),
        JS_MAKE_ENUM_VALUE(VirtualKey, W),
        JS_MAKE_ENUM_VALUE(VirtualKey, X),
        JS_MAKE_ENUM_VALUE(VirtualKey, Y),
        JS_MAKE_ENUM_VALUE(VirtualKey, Z),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number1),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number2),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number3),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number4),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number5),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number6),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number7),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number8),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number9),
        JS_MAKE_ENUM_VALUE(VirtualKey, Number0),
        JS_MAKE_ENUM_VALUE(VirtualKey, Return),
        JS_MAKE_ENUM_VALUE(VirtualKey, Escape),
        JS_MAKE_ENUM_VALUE(VirtualKey, Backspace),
        JS_MAKE_ENUM_VALUE(VirtualKey, Tab),
        JS_MAKE_ENUM_VALUE(VirtualKey, Space),
        JS_MAKE_ENUM_VALUE(VirtualKey, Minus),
        JS_MAKE_ENUM_VALUE(VirtualKey, Equals),
        JS_MAKE_ENUM_VALUE(VirtualKey, LeftBracket),
        JS_MAKE_ENUM_VALUE(VirtualKey, RightBracket),
        JS_MAKE_ENUM_VALUE(VirtualKey, Backslash),
        JS_MAKE_ENUM_VALUE(VirtualKey, Semicolon),
        JS_MAKE_ENUM_VALUE(VirtualKey, Apostrophe),
        JS_MAKE_ENUM_VALUE(VirtualKey, Grave),
        JS_MAKE_ENUM_VALUE(VirtualKey, Comma),
        JS_MAKE_ENUM_VALUE(VirtualKey, Period),
        JS_MAKE_ENUM_VALUE(VirtualKey, Slash),
        JS_MAKE_ENUM_VALUE(VirtualKey, CapsLock),
        JS_MAKE_ENUM_VALUE(VirtualKey, F1),
        JS_MAKE_ENUM_VALUE(VirtualKey, F2),
        JS_MAKE_ENUM_VALUE(VirtualKey, F3),
        JS_MAKE_ENUM_VALUE(VirtualKey, F4),
        JS_MAKE_ENUM_VALUE(VirtualKey, F5),
        JS_MAKE_ENUM_VALUE(VirtualKey, F6),
        JS_MAKE_ENUM_VALUE(VirtualKey, F7),
        JS_MAKE_ENUM_VALUE(VirtualKey, F8),
        JS_MAKE_ENUM_VALUE(VirtualKey, F9),
        JS_MAKE_ENUM_VALUE(VirtualKey, F10),
        JS_MAKE_ENUM_VALUE(VirtualKey, F11),
        JS_MAKE_ENUM_VALUE(VirtualKey, F12),
        JS_MAKE_ENUM_VALUE(VirtualKey, PrintScreen),
        JS_MAKE_ENUM_VALUE(VirtualKey, ScrollLock),
        JS_MAKE_ENUM_VALUE(VirtualKey, Pause),
        JS_MAKE_ENUM_VALUE(VirtualKey, Insert),
        JS_MAKE_ENUM_VALUE(VirtualKey, Home),
        JS_MAKE_ENUM_VALUE(VirtualKey, PageUp),
        JS_MAKE_ENUM_VALUE(VirtualKey, Delete),
        JS_MAKE_ENUM_VALUE(VirtualKey, End),
        JS_MAKE_ENUM_VALUE(VirtualKey, PageDown),
        JS_MAKE_ENUM_VALUE(VirtualKey, Right),
        JS_MAKE_ENUM_VALUE(VirtualKey, Left),
        JS_MAKE_ENUM_VALUE(VirtualKey, Down),
        JS_MAKE_ENUM_VALUE(VirtualKey, Up),
        JS_MAKE_ENUM_VALUE(VirtualKey, NumLock),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_Divide),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_Multiply),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_Minus),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_Plus),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_Enter),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_1),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_2),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_3),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_4),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_5),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_6),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_7),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_8),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_9),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_0),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_Period),
        JS_MAKE_ENUM_VALUE(VirtualKey, LessThan),
        JS_MAKE_ENUM_VALUE(VirtualKey, Application),
        JS_MAKE_ENUM_VALUE(VirtualKey, Power),
        JS_MAKE_ENUM_VALUE(VirtualKey, KP_Equals),
        JS_MAKE_ENUM_VALUE(VirtualKey, F13),
        JS_MAKE_ENUM_VALUE(VirtualKey, F14),
        JS_MAKE_ENUM_VALUE(VirtualKey, F15),
        JS_MAKE_ENUM_VALUE(VirtualKey, F16),
        JS_MAKE_ENUM_VALUE(VirtualKey, F17),
        JS_MAKE_ENUM_VALUE(VirtualKey, F18),
        JS_MAKE_ENUM_VALUE(VirtualKey, F19),
        JS_MAKE_ENUM_VALUE(VirtualKey, F20),
        JS_MAKE_ENUM_VALUE(VirtualKey, F21),
        JS_MAKE_ENUM_VALUE(VirtualKey, F22),
        JS_MAKE_ENUM_VALUE(VirtualKey, F23),
        JS_MAKE_ENUM_VALUE(VirtualKey, F24),
        JS_MAKE_ENUM_VALUE(VirtualKey, LeftCtrl),
        JS_MAKE_ENUM_VALUE(VirtualKey, LeftShift),
        JS_MAKE_ENUM_VALUE(VirtualKey, LeftAlt),
        JS_MAKE_ENUM_VALUE(VirtualKey, LeftSuper),
        JS_MAKE_ENUM_VALUE(VirtualKey, RightCtrl),
        JS_MAKE_ENUM_VALUE(VirtualKey, RightShift),
        JS_MAKE_ENUM_VALUE(VirtualKey, RightAlt),
        JS_MAKE_ENUM_VALUE(VirtualKey, RightSuper),
        JS_MAKE_ENUM_VALUE(VirtualKey, Mode),
        JS_MAKE_ENUM_VALUE(VirtualKey, KeyCount),
        {nullptr, nullptr, nullptr, kJSPropertyAttributeNone}
    };
    static const JSClassDefinition virtualkey_definition = create_class_definition(
        "VirtualKey",
        virtualkey_static_values,
        nullptr,
        nullptr,
        nullptr
    );

    const JSClassDefinition rainbow_definition{
        0,                      // version
        kJSClassAttributeNone,  // attributes
        "Rainbow",              // className
        nullptr,                // parentClass
        nullptr,                // staticValues
        nullptr,                // staticFunctions
        nullptr,                // initialize
        nullptr,                // finalize
        nullptr,                // hasProperty
        nullptr,                // getProperty
        nullptr,                // setProperty
        nullptr,                // deleteProperty
        nullptr,                // getPropertyNames
        nullptr,                // callAsFunction
        nullptr,                // callAsConstructor
        nullptr,                // hasInstance
        nullptr,                // convertToType
    };

    auto rainbow_object = JSObjectMake(
        global_context, UniqueClassRef(&rainbow_definition), nullptr);
    JS_SET_CONSTRUCTOR(global_context, rainbow_object, Animation, animation);
    JS_SET_ENUM(global_context, rainbow_object, AnimationEvent, animationevent);
    JS_SET_ENUM(global_context, rainbow_object, ControllerAxis, controlleraxis);
    JS_SET_ENUM(global_context, rainbow_object, ControllerButton, controllerbutton);
    JS_SET_CONSTRUCTOR(global_context, rainbow_object, Label, label);
    JS_SET_CONSTRUCTOR(global_context, rainbow_object, Sprite, sprite);
    JS_SET_CONSTRUCTOR(global_context, rainbow_object, SpriteBatch, spritebatch);
    JS_SET_ENUM(global_context, rainbow_object, TextAlignment, textalignment);
    JS_SET_CONSTRUCTOR(global_context, rainbow_object, Texture, texture);
    JS_SET_ENUM(global_context, rainbow_object, VirtualKey, virtualkey);

    JSObjectSetProperty(
        global_context,
        JSContextGetGlobalObject(global_context),
        UniqueStringRef("Rainbow"),
        rainbow_object,
        kJSPropertyAttributeReadOnly | kJSPropertyAttributeDontDelete,
        nullptr);
    return rainbow_object;
}

#undef JS_SET_ENUM
#undef JS_SET_CONSTRUCTOR
#undef JS_MAKE_FUNCTION
#undef JS_MAKE_ENUM_VALUE

// clang-format on

#endif
