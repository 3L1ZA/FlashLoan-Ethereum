<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Rainbow API Reference</title>
	<link rel="stylesheet" type="text/css" href="style.css">
	<style type="text/css">
		#top {
			position: fixed;
			bottom: 16px;
			right: 16px;
		}
		.optional:before {
			font-size: 0.7em;
			font-weight: bold;
			content: '[optional] ';
		}
		h1 {  /* RAINBOW! */
			color: #ffffff !important;
			text-shadow:
				 2px  1px 0 #dd0000,  4px  2px 0 #dd0000,
				 6px  3px 0 #fe6230,  8px  4px 0 #fe6230,
				10px  5px 0 #fef600, 12px  6px 0 #fef600,
				14px  7px 0 #00bc00, 16px  8px 0 #00bc00,
				18px  9px 0 #009bfe, 20px 10px 0 #009bfe,
				22px 11px 0 #000083, 24px 12px 0 #000083,
				26px 13px 0 #30009b, 28px 14px 0 #30009b !important;
		}
		h2 { margin-top: 63px !important; }
		h3 { margin-top: 37px !important; }
		ul {
			-moz-column-count: 4;     /* Firefox */
			-webkit-column-count: 4;  /* Safari and Chrome */
			column-count: 4;
			list-style: none;
		}
		xmp { display: none; }
	</style>
</head>
<body>
<xmp id="content" theme="simplex">

  * [animation](#rainbow.animation)
  * [audio](#rainbow.audio)
  * [coroutine](#rainbow.coroutine)
  * [font](#rainbow.font)
  * [input](#rainbow.input)
  * [io](#rainbow.io)
  * [label](#rainbow.label)
  * [math](#rainbow.math)
  * [platform](#rainbow.platform)
  * [random](#rainbow.random)
  * [renderer](#rainbow.renderer)
  * [scenegraph](#rainbow.scenegraph)
  * [sprite](#rainbow.sprite)
  * [spritebatch](#rainbow.spritebatch)
  * [stack](#rainbow.stack)
  * [texture](#rainbow.texture)
  * [timer](#rainbow.timer)
  * [transition](#rainbow.transition)
  * &mdash;
  * [Box2D](http://box2d.org/documentation/)

<a id="rainbow.animation"></a>
## rainbow.animation

Sprite animations use separate textures within a [texture atlas](#rainbow.texture) as animation frames. Since animations are bound to a [sprite](#rainbow.sprite), which in turn is bound to a [sprite batch](#rainbow.spritebatch), they are also bound to the [texture atlas](#rainbow.texture) the batch is using.

<a id="rainbow.animation()"></a>
### rainbow.animation(sprite, frames, fps, delay)

<table>
	<tr>
		<td><var>sprite</var></td>
		<td>The sprite object to animate.</td>
	</tr>
	<tr>
		<td><var>frames</var></td>
		<td>Array of frames that make up the animation.</td>
	</tr>
	<tr>
		<td><var>fps</var></td>
		<td>Number of frames per second to animate at.</td>
	</tr>
	<tr>
		<td><var>delay</var></td>
		<td>Number of frames to delay before looping. Negative numbers disable looping. Default: 0.</td>
	</tr>
</table>

Creates a sprite animation.

<a id="rainbow.animation:is_stopped"></a>
### &lt;rainbow.animation&gt;:is_stopped()

Returns whether the animation has stopped.

<a id="rainbow.animation:set_delay"></a>
### &lt;rainbow.animation&gt;:set_delay(delay)

<table>
	<tr>
		<td><var>delay</var></td>
		<td>Number of milliseconds to delay before looping.</td>
	</tr>
</table>

Sets the number of milliseconds to delay before looping.

<a id="rainbow.animation:set_fps"></a>
### &lt;rainbow.animation&gt;:set_fps(fps)

<table>
	<tr>
		<td><var>fps</var></td>
		<td>Number of frames per second to animate at.</td>
	</tr>
</table>

Sets the number of frames per second to animate at.

<a id="rainbow.animation:set_frames"></a>
### &lt;rainbow.animation&gt;:set_frames(frames)

<table>
	<tr>
		<td><var>frames</var></td>
		<td>Table of texture indices that make up the animation.</td>
	</tr>
</table>

Sets table of animation frames.

<a id="rainbow.animation:set_sprite"></a>
### &lt;rainbow.animation&gt;:set_sprite(sprite)

<table>
	<tr>
		<td><var>sprite</var></td>
		<td>The sprite to animate.</td>
	</tr>
</table>

Sets the sprite to animate.

<a id="rainbow.animation:play"></a>
### &lt;rainbow.animation&gt;:play()

Starts the animation.

<a id="rainbow.animation:stop"></a>
### &lt;rainbow.animation&gt;:stop()

Stops the animation.

<a id="rainbow.audio"></a>
## rainbow.audio

Audio consists mainly of the sound object and the audio channel. The sound object is basically an audio buffer. It can be wholly loaded, or it can stream from disk. A sound object is played on an audio channel. An audio channel can only play one sound object at a time but the sound object can be used by any number of channels. As raw audio data can take a large amount of memory, it is recommended to only create static sound objects for short audio files (such as sound effects).

Officially, Rainbow supports only [Ogg Vorbis](http://en.wikipedia.org/wiki/Vorbis) audio format. However, on iOS, the [list of supported audio formats](http://developer.apple.com/library/ios/#documentation/AudioVideo/Conceptual/MultimediaPG/UsingAudio/UsingAudio.html#//apple_ref/doc/uid/TP40009767-CH2-SW9) includes AAC (MPEG-4 Advanced Audio Coding), ALAC (Apple Lossless), HE-AAC (MPEG-4 High Efficiency AAC), iLBC (internet Low Bit Rate Codec), IMA4 (IMA/ADPCM), Linear PCM (uncompressed, linear pulse code modulation), MP3, Âµ-law and a-law. Of these, AAC, ALAC, HE-AAC and MP3 are hardware-assisted. Mac OS X also supports these in addition to [Ogg Vorbis](http://en.wikipedia.org/wiki/Vorbis). On Android, the list of supported audio formats vary with each device but MP3 and Ogg Vorbis are both safe bets.

<a id="rainbow.audio.clear"></a>
### rainbow.audio.clear()

Stops and deletes all sound objects.

<a id="rainbow.audio.create_sound"></a>
### rainbow.audio.create_sound(path, +mode, +loops)

<table>
	<tr>
		<td><var>path</var></td>
		<td>Path to audio source, relative to the location of the main script.</td>
	</tr>
	<tr>
		<td><var>mode</var></td>
		<td class="optional">Load into buffer (0), or stream from disk (1). Default: 0.</td>
	</tr>
	<tr>
		<td><var>loops</var></td>
		<td class="optional">Number of times to loop. Only applicable if streaming. Default: -1.</td>
	</tr>
</table>

Creates a sound object. This object is just a reference to the audio source and cannot be manipulated in any way.

<a id="rainbow.audio.delete_sound"></a>
### rainbow.audio.delete_sound(sound)

<table>
	<tr>
		<td><var>sound</var></td>
		<td>The sound object to delete.</td>
	</tr>
</table>

Deletes sound object. This will stop all channels from using the object and release all related resources.

<a id="rainbow.audio.pause"></a>
### rainbow.audio.pause(channel)

<table>
	<tr>
		<td><var>channel</var></td>
		<td>The channel to pause playback.</td>
	</tr>
</table>

Sets channel on pause.

<a id="rainbow.audio.play"></a>
### rainbow.audio.play(sound)

<table>
	<tr>
		<td><var>sound</var></td>
		<td>The sound object to play.</td>
	</tr>
</table>

Starts playback of the sound object and returns the channel on which it is played. Channels may vary with each playback.

<a id="rainbow.audio.set_gain"></a>
### rainbow.audio.set_gain(+channel, volume)

<table>
	<tr>
		<td><var>channel</var></td>
		<td class="optional">The channel to change gain/volume. Default: master channel.</td>
	</tr>
	<tr>
		<td><var>volume</var></td>
		<td>Desired gain/volume. Valid values: 0.0-1.0.</td>
	</tr>
</table>

Sets channel gain/volume.

<a id="rainbow.audio.set_pitch"></a>
### rainbow.audio.set_pitch(pitch)

<table>
	<tr>
		<td><var>pitch</var></td>
		<td>Desired pitch shift, where 1.0 equals identify. Each reduction by 50 percent equals a pitch shift of -12 semitones (one octave reduction). Each doubling equals a pitch shift of 12 semitones (one octave increase). Zero is not a legal value.</td>
	</tr>
</table>

Sets global pitch shift.

<a id="rainbow.audio.stop"></a>
### rainbow.audio.stop(channel)

<table>
	<tr>
		<td><var>channel</var></td>
		<td>The channel to stop playback.</td>
	</tr>
</table>

Stops channel.

<a id="rainbow.coroutine"></a>
## rainbow.coroutine

<a id="rainbow.coroutine.start"></a>
### rainbow.coroutine.start(function)

<table>
	<tr>
		<td><var>function</var></td>
		<td>Function to execute in a coroutine.</td>
	</tr>
</table>

Creates and starts a coroutine.

<a id="rainbow.coroutine.wait"></a>
### rainbow.coroutine.wait(milliseconds)

<table>
	<tr>
		<td><var>milliseconds</var></td>
		<td>Number of milliseconds to wait before continuing.</td>
	</tr>
</table>

Blocks a coroutine for a certain amount of time.

<a id="rainbow.font"></a>
## rainbow.font

Font objects are used by [labels](#rainbow.label) to display text. Like textures, it is recommended to reuse them whenever possible. A font object is created with a fixed point size and cannot be resized. If a different size is desired, a new font object must be created.

<a id="rainbow.font()"></a>
### rainbow.font(path, size)

<table>
	<tr>
		<td><var>path</var></td>
		<td>Path to font, relative to the location of the main script.</td>
	</tr>
	<tr>
		<td><var>size</var></td>
		<td>Point size.</td>
	</tr>
</table>

Creates a font with a fixed point size.

<a id="rainbow.input"></a>
## rainbow.input

Input events are only sent to objects that subscribe to them. Such objects are called event listeners. A listener can be implemented as follows.

	InputListener = {}
	InputListener.__index = InputListener

	function InputListener:key_down(key, modifiers) end
	function InputListener:key_up(key, modifiers) end
	function InputListener:touch_ended(touches) end
	function InputListener:touch_canceled() end
	function InputListener:touch_moved(touches) end

	# Create our listener and let it subscribe to input events.
	local mylistener = setmetatable({}, InputListener)
	rainbow.input.subscribe(mylistener)

	# We're only interested in touch began events.
	function mylistener:touch_began(touches)
		for hash,touch in pairs(touches) do
			# Handle event here
		end
	end

As seen in the example, the easiest way is to define an ``InputListener`` and inherit from it, then define the functions that are needed. The important point here is that all event handlers must be implemented even if they'll do nothing.

For touch events, a table of events are sent with each notification. It is iterated as above. The ``hash`` value uniquely identifies a touch (or mouse button) for the duration of it touching the screen (or mouse button being held). Touch (or mouse click) location is stored in ``touch``:

	touch.x          # For the x-coordinate.
	touch.y          # For the y-coordinate.
	touch.timestamp  # For the relative time at which the event occurred.

_Desktop-only:_ Keyboard event listeners receive the key value (the actual key that was pressed/released) of the event and, if available, its modifiers (i.e. ctrl, alt or shift).

<a id="rainbow.input.subscribe"></a>
### rainbow.input.subscribe(listener)

<table>
	<tr>
		<td><var>listener</var></td>
		<td>Input listener object.</td>
	</tr>
</table>

Adds an input listener.

<a id="rainbow.input.unsubscribe"></a>
### rainbow.input.unsubscribe(listener)

<table>
	<tr>
		<td><var>listener</var></td>
		<td>Input listener object.</td>
	</tr>
</table>

Removes an input listener.

<a id="rainbow.input.unsubscribe_all"></a>
### rainbow.input.unsubscribe_all()

Removes all input listeners.

<a id="rainbow.io"></a>
## rainbow.io

<a id="rainbow.io.load"></a>
### rainbow.io.load()

<a id="rainbow.io.save"></a>
### rainbow.io.save()

<a id="rainbow.label"></a>
## rainbow.label

A label is used to display text.

<a id="rainbow.label()"></a>
### rainbow.label(+text)

<table>
	<tr>
		<td><var>text</var></td>
		<td class="optional">The text to be displayed on the label. Default: "".</td>
	</tr>
</table>

<a id="rainbow.label:get_color"></a>
### &lt;rainbow.label&gt;:get_color()

Returns the font colour in separate channels (RGBA).

<a id="rainbow.label:set_alignment"></a>
### &lt;rainbow.label&gt;:set_alignment(align)

<table>
	<tr>
		<td><var>align</var></td>
		<td>Text alignment. Valid values: 'l', 'c', 'r'. Default: 'l'.</td>
	</tr>
</table>

Sets text alignment.

<a id="rainbow.label:set_color"></a>
### &lt;rainbow.label&gt;:set_color(r, g, b, +a)

<table>
	<tr>
		<td><var>r</var></td>
		<td>Amount of red. Valid values: 0-255.</td>
	</tr>
	<tr>
		<td><var>g</var></td>
		<td>Amount of green. Valid values: 0-255.</td>
	</tr>
	<tr>
		<td><var>b</var></td>
		<td>Amount of blue. Valid values: 0-255.</td>
	</tr>
	<tr>
		<td><var>a</var></td>
		<td class="optional">Amount of opacity. Valid values: 0-255. Default: 255.</td>
	</tr>
</table>

Sets text colour.

<a id="rainbow.label:set_font"></a>
### &lt;rainbow.label&gt;:set_font(font)

<table>
	<tr>
		<td><var>font</var></td>
		<td>[Font type](#rainbow.font) to use.</td>
	</tr>
</table>

Sets font type.

<a id="rainbow.label:set_position"></a>
### &lt;rainbow.label&gt;:set_position(x, y)

<table>
	<tr>
		<td><var>x, y</var></td>
		<td>Position.</td>
	</tr>
</table>

Sets label position.

<a id="rainbow.label:set_scale"></a>
### &lt;rainbow.label&gt;:set_scale(scale)

<table>
	<tr>
		<td><var>scale</var></td>
		<td>Factor to scale label by. Valid values: 0.01-1.0.</td>
	</tr>
</table>

Sets label scale. Values are clamped between 0.01-1.0.

<a id="rainbow.label:set_text"></a>
### &lt;rainbow.label&gt;:set_text(text)

<table>
	<tr>
		<td><var>text</var></td>
		<td>Text to be displayed on the label.</td>
	</tr>
</table>

Sets the text to be displayed on the label.

<a id="rainbow.math"></a>
## rainbow.math

Useful mathematical functions.

<a id="rainbow.math.G"></a>
### rainbow.math.G

The universal gravitation constant, defined as G = 6.67384 * 10<sup>-11</sup> N(m/kg)<sup>2</sup>.

<a id="rainbow.math.angle"></a>
### rainbow.math.angle(a.x, a.y, b.x, b.y)

<table>
	<tr>
		<td><var>a.x, a.y</var></td>
		<td>The first point.</td>
	</tr>
	<tr>
		<td><var>b.x, b.y</var></td>
		<td>The second point.</td>
	</tr>
</table>

Calculates the angle between two points.

<a id="rainbow.math.clamp"></a>
### rainbow.math.clamp(x, min, max)

<table>
	<tr>
		<td><var>x</var></td>
		<td>The value to clamp.</td>
	</tr>
	<tr>
		<td><var>min</var></td>
		<td>Lowest acceptable value.</td>
	</tr>
	<tr>
		<td><var>max</var></td>
		<td>Highest acceptable value.</td>
	</tr>
</table>

Returns the input value clamped between a range [<var>min</var>, <var>max</var>].

<a id="rainbow.math.degrees"></a>
### rainbow.math.degrees(radians)

<table>
	<tr>
		<td><var>radians</var></td>
		<td>The value to convert to degrees.</td>
	</tr>
</table>

Converts radians to degrees.

<a id="rainbow.math.distance"></a>
### rainbow.math.distance(a.x, a.y, b.x, b.y)

<table>
	<tr>
		<td><var>a.x, a.y</var></td>
		<td>The first point.</td>
	</tr>
	<tr>
		<td><var>b.x, b.y</var></td>
		<td>The second point.</td>
	</tr>
</table>

Calculates the distance between two points.

<a id="rainbow.math.gravitation"></a>
### rainbow.math.gravitation(m1, m2, r)

<table>
	<tr>
		<td><var>m1</var></td>
		<td>The first mass.</td>
	</tr>
	<tr>
		<td><var>m2</var></td>
		<td>The second mass.</td>
	</tr>
	<tr>
		<td><var>r</var></td>
		<td>Distance between the centers of the masses.</td>
	</tr>
</table>

Newton's law of universal gravitation: F = G * (m<sub>1</sub> * m<sub>2</sub>) / r<sup>2</sup>.

<a id="rainbow.math.hitbox"></a>
### rainbow.math.hitbox(x, y, width,height, scale)

<table>
	<tr>
		<td><var>x, y</var></td>
		<td>Centre of the box.</td>
	</tr>
	<tr>
		<td><var>width,height</var></td>
		<td>Dimension of the box.</td>
	</tr>
	<tr>
		<td><var>scale</var></td>
		<td>Scaling factor for on-screen box size.</td>
	</tr>
</table>

Creates a hitbox.

<a id="rainbow.math.is_inside"></a>
### rainbow.math.is_inside(box, point)

<table>
	<tr>
		<td><var>box</var></td>
		<td>Table with the upper-left and lower-right points of the box.</td>
	</tr>
	<tr>
		<td><var>point</var></td>
		<td>The point to check.</td>
	</tr>
</table>

Checks whether a point is inside a box.

<a id="rainbow.math.radians"></a>
### rainbow.math.radians(degrees)

<table>
	<tr>
		<td><var>degrees</var></td>
		<td>The value to convert to radians.</td>
	</tr>
</table>

Converts degrees to radians.

<a id="rainbow.platform"></a>
## rainbow.platform

Query the system for capabilities or sensor readings.

<a id="rainbow.platform.accelerometer"></a>
### rainbow.platform.accelerometer

<table>
	<tr>
		<td><var>timestamp</var></td>
		<td>The relative time at which the acceleration event occurred.</td>
	</tr>
	<tr>
		<td><var>x</var></td>
		<td>The acceleration value for the x axis of the device. With the device held in portrait orientation and the screen facing you, the x axis runs from left (negative values) to right (positive values) across the face of the device.</td>
	</tr>
	<tr>
		<td><var>y</var></td>
		<td>The acceleration value for the y axis of the device. With the device held in portrait orientation and the screen facing you, the y axis runs from bottom (negative values) to top (positive values) across the face of the device.</td>
	</tr>
	<tr>
		<td><var>z</var></td>
		<td>The acceleration value for the z axis of the device. With the device held in portrait orientation and the screen facing you, the z axis runs from back (negative values) to front (positive values) through the device.</td>
	</tr>
</table>

<a id="rainbow.platform.screen"></a>
### rainbow.platform.screen

<table>
	<tr>
		<td><var>width</var></td>
		<td>Screen width in pixels.</td>
	</tr>
	<tr>
		<td><var>height</var></td>
		<td>Screen height in pixels.</td>
	</tr>
	<tr>
		<td><var>touch</var></td>
		<td>Whether the screen has touch capabilities.</td>
	</tr>
</table>

<a id="rainbow.platform.memory"></a>
### rainbow.platform.memory

Total amount of RAM in MB.

<a id="rainbow.random"></a>
## rainbow.random

Rainbow's pseudo-random number generator is the [Double precision SIMD-oriented Fast Mersenne Twister](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/SFMT/) developed by Mutsuo Saito and Makoto Matsumoto at Hiroshima University and University of Tokyo. The implementation in use supports a period of 2<sup>19937</sup> - 1.

``rainbow.seed()`` must be called before using this module.

<a id="rainbow.random()"></a>
### rainbow.random()

Returns a random number in interval [0, 1).

<a id="rainbow.random()"></a>
### rainbow.random(max)

<table>
	<tr>
		<td><var>max</var></td>
		<td>Maximum value.</td>
	</tr>
</table>

Returns a random number in interval [0, <var>max</var>).

<a id="rainbow.random()"></a>
### rainbow.random(min, max)

<table>
	<tr>
		<td><var>min</var></td>
		<td>Minimum value.</td>
	</tr>
	<tr>
		<td><var>max</var></td>
		<td>Maximum value.</td>
	</tr>
</table>

Returns a random number in interval [<var>min</var>, <var>max</var>).

<a id="rainbow.random#seed"></a>
### rainbow.seed(+seed)

<table>
	<tr>
		<td><var>seed</var></td>
		<td class="optional">Random number generator seed. Default: 0 (current system time).</td>
	</tr>
</table>

Sets the random number generator seed. Must be called before any other calls.

<a id="rainbow.renderer"></a>
## rainbow.renderer

Access low-level graphics methods and properties.

<a id="rainbow.renderer.max_texture_size"></a>
### rainbow.renderer.max_texture_size

Rough estimate of the largest texture that the platform can handle.

<a id="rainbow.renderer.supports_pvrtc"></a>
### rainbow.renderer.supports_pvrtc

Whether the platform supports PVRTC textures.

<a id="rainbow.renderer.set_clear_color"></a>
### rainbow.renderer.set_clear_color(r, g, b)

<table>
	<tr>
		<td><var>r</var></td>
		<td>Amount of red. Valid values: 0-255.</td>
	</tr>
	<tr>
		<td><var>g</var></td>
		<td>Amount of green. Valid values: 0-255.</td>
	</tr>
	<tr>
		<td><var>b</var></td>
		<td>Amount of blue. Valid values: 0-255.</td>
	</tr>
</table>

Sets clear colour. Clearing occurs at the start of each drawn frame.

<a id="rainbow.renderer.set_filter"></a>
### rainbow.renderer.set_filter(filter)

<table>
	<tr>
		<td><var>filter</var></td>
		<td>Texture filtering method. Valid values: ``gl.NEAREST``, ``gl.LINEAR``.</td>
	</tr>
</table>

Sets texture filtering method. Only affects new textures.

<a id="rainbow.renderer.set_projection"></a>
### rainbow.renderer.set_projection(left, right, bottom, top)

<table>
	<tr>
		<td><var>left</var></td>
		<td>Leftmost point in pixels. Default: 0.</td>
	</tr>
	<tr>
		<td><var>right</var></td>
		<td>Rightmost point in pixels. Default: [``rainbow.platform.screen.width``](#rainbow.platform.screen).</td>
	</tr>
	<tr>
		<td><var>bottom</var></td>
		<td>Bottommost point in pixels. Default: 0.</td>
	</tr>
	<tr>
		<td><var>top</var></td>
		<td>Topmost point in pixels. Default: [``rainbow.platform.screen.height``](#rainbow.platform.screen).</td>
	</tr>
</table>

Sets orthographic projection.

<a id="rainbow.scenegraph"></a>
## rainbow.scenegraph

Drawables must be attached to the scene graph in order to be updated and drawn. The scene graph is traversed in a depth-first manner. In a single node, this means that its children are updated and drawn in the order they were created.

<a id="rainbow.scenegraph:add_animation"></a>
### &lt;rainbow.scenegraph&gt;:add_animation(+parent, animation)

<table>
	<tr>
		<td><var>parent</var></td>
		<td class="optional">Parent node to attach to. Default: root.</td>
	</tr>
	<tr>
		<td><var>animation</var></td>
		<td>The [animation](#rainbow.animation) to attach to the graph.</td>
	</tr>
</table>

Creates a node containing a [sprite animation](#rainbow.animation).

<a id="rainbow.scenegraph:add_batch"></a>
### &lt;rainbow.scenegraph&gt;:add_batch(+parent, spritebatch)

<table>
	<tr>
		<td><var>parent</var></td>
		<td class="optional">Parent node to attach to. Default: root.</td>
	</tr>
	<tr>
		<td><var>spritebatch</var></td>
		<td>The [sprite batch](#rainbow.spritebatch) to attach to the graph.</td>
	</tr>
</table>

Creates a node containing a [sprite batch](#rainbow.spritebatch).

<a id="rainbow.scenegraph:add_drawable"></a>
### &lt;rainbow.scenegraph&gt;:add_drawable(+parent, drawable)

<table>
	<tr>
		<td><var>parent</var></td>
		<td class="optional">Parent node to attach to. Default: root.</td>
	</tr>
	<tr>
		<td><var>drawable</var></td>
		<td>The drawable object to attach to the graph.</td>
	</tr>
</table>

Creates a node containing a drawable.

<a id="rainbow.scenegraph:add_node"></a>
### &lt;rainbow.scenegraph&gt;:add_node(+parent)

<table>
	<tr>
		<td><var>parent</var></td>
		<td class="optional">Parent node to attach to. Default: root.</td>
	</tr>
</table>

Creates a group node.

<a id="rainbow.scenegraph:add_label"></a>
### &lt;rainbow.scenegraph&gt;:add_label(+parent, label)

<table>
	<tr>
		<td><var>parent</var></td>
		<td class="optional">Parent node to attach to. Default: root.</td>
	</tr>
	<tr>
		<td><var>label</var></td>
		<td>The [label](#rainbow.label) to attach to the graph.</td>
	</tr>
</table>

Creates a node containing a [label](#rainbow.label).

<a id="rainbow.scenegraph:disable"></a>
### &lt;rainbow.scenegraph&gt;:disable(node)

<table>
	<tr>
		<td><var>node</var></td>
		<td>The node to disable.</td>
	</tr>
</table>

Disables a node. Disabling a node will cut short the graph traversal, effectively disabling all children nodes but still maintain their states.

<a id="rainbow.scenegraph:enable"></a>
### &lt;rainbow.scenegraph&gt;:enable(node)

<table>
	<tr>
		<td><var>node</var></td>
		<td>The node to enable.</td>
	</tr>
</table>

Enables a node. Enabling a node will open up the path in the graph, effectively enabling all children nodes but still maintain their states.

<a id="rainbow.scenegraph:move"></a>
### &lt;rainbow.scenegraph&gt;:move(node, x, y)

<table>
	<tr>
		<td><var>node</var></td>
		<td>The node to move.</td>
	</tr>
	<tr>
		<td><var>x, y</var></td>
		<td>Amount to move the node by.</td>
	</tr>
</table>

Moves a node and all of its children by (x,y).

<a id="rainbow.scenegraph:remove"></a>
### &lt;rainbow.scenegraph&gt;:remove(node)

<table>
	<tr>
		<td><var>node</var></td>
		<td>The node to remove.</td>
	</tr>
</table>

Removes a node and all of its children from the graph.

<a id="rainbow.scenegraph:set_parent"></a>
### &lt;rainbow.scenegraph&gt;:set_parent(parent, node)

<table>
	<tr>
		<td><var>parent</var></td>
		<td>The new parent.</td>
	</tr>
	<tr>
		<td><var>node</var></td>
		<td>The node to move.</td>
	</tr>
</table>

Moves node to a new parent node.

<a id="rainbow.sprite"></a>
## rainbow.sprite

A sprite is a textured quad in a coordinate system with the origin at the lower left corner of the screen. Sprites are created by a [sprite batch](#rainbow.spritebatch) and uses the [texture atlas](#rainbow.texture) assigned to the batch.

<a id="rainbow.sprite:get_angle"></a>
### &lt;rainbow.sprite&gt;:get_angle()

Returns sprite orientation in radians.

<a id="rainbow.sprite:get_color"></a>
### &lt;rainbow.sprite&gt;:get_color()

Returns sprite colour in separate channels (RGBA).

<a id="rainbow.sprite:get_position"></a>
### &lt;rainbow.sprite&gt;:get_position()

Returns sprite position.

<a id="rainbow.sprite:set_color"></a>
### &lt;rainbow.sprite&gt;:set_color(r, g, b, +a)

<table>
	<tr>
		<td><var>r</var></td>
		<td>Amount of red. Valid values: 0-255.</td>
	</tr>
	<tr>
		<td><var>g</var></td>
		<td>Amount of green. Valid values: 0-255.</td>
	</tr>
	<tr>
		<td><var>b</var></td>
		<td>Amount of blue. Valid values: 0-255.</td>
	</tr>
	<tr>
		<td><var>a</var></td>
		<td class="optional">Amount of opacity. Valid values: 0-255. Default: 255.</td>
	</tr>
</table>

Sets sprite colour.

<a id="rainbow.sprite:set_pivot"></a>
### &lt;rainbow.sprite&gt;:set_pivot(x, y)

<table>
	<tr>
		<td><var>x, y</var></td>
		<td>Pivot point. Default: 0.5, 0.5.</td>
	</tr>
</table>

Sets sprite's pivot point.

<a id="rainbow.sprite:set_position"></a>
### &lt;rainbow.sprite&gt;:set_position(x, y)

<table>
	<tr>
		<td><var>x, y</var></td>
		<td>Position. Default: 0, 0.</td>
	</tr>
</table>

Sets sprite position.

<a id="rainbow.sprite:set_rotation"></a>
### &lt;rainbow.sprite&gt;:set_rotation(r)

<table>
	<tr>
		<td><var>r</var></td>
		<td>Angle in radians. Default: 0.0.</td>
	</tr>
</table>

Sets sprite rotation.

<a id="rainbow.sprite:set_scale"></a>
### &lt;rainbow.sprite&gt;:set_scale(f)

<table>
	<tr>
		<td><var>f</var></td>
		<td>Scale factor. Default: 1.0.</td>
	</tr>
</table>

Sets sprite scale.

<a id="rainbow.sprite:set_texture"></a>
### &lt;rainbow.sprite&gt;:set_texture(texture)

<table>
	<tr>
		<td><var>texture</var></td>
		<td>Texture id.</td>
	</tr>
</table>

Assigns texture to sprite.

<a id="rainbow.sprite:mirror"></a>
### &lt;rainbow.sprite&gt;:mirror()

Horizontally mirrors sprite's current texture.

<a id="rainbow.sprite:move"></a>
### &lt;rainbow.sprite&gt;:move(x, y)

<table>
	<tr>
		<td><var>x, y</var></td>
		<td>Amount to move sprite by.</td>
	</tr>
</table>

Moves sprite by (x,y).

<a id="rainbow.sprite:rotate"></a>
### &lt;rainbow.sprite&gt;:rotate(r)

<table>
	<tr>
		<td><var>r</var></td>
		<td>Amount to rotate sprite by.</td>
	</tr>
</table>

Rotates sprite by given angle.

<a id="rainbow.spritebatch"></a>
## rainbow.spritebatch

Sprite batches are meant to enforce grouping of [sprites](#rainbow.sprite) in order to avoid drawing each [sprite](#rainbow.sprite) separately.

The sprites in a batch are drawn using [painter's algorithm](http://en.wikipedia.org/wiki/Painter's_algorithm) and should therefore be created in the order they want to be drawn.

<a id="rainbow.spritebatch()"></a>
### rainbow.spritebatch(+hint)

<table>
	<tr>
		<td><var>hint</var></td>
		<td class="optional">Number of [sprites](#rainbow.sprite) to make space for. Default: 8.</td>
	</tr>
</table>

Creates a batch of [sprites](#rainbow.sprite).

<a id="rainbow.spritebatch:create_sprite"></a>
### &lt;rainbow.spritebatch&gt;:create_sprite(width, height)

<table>
	<tr>
		<td><var>width, height</var></td>
		<td>Dimension of the [sprite](#rainbow.sprite) to create.</td>
	</tr>
</table>

Creates an untextured [sprite](#rainbow.sprite) with given dimension and places it at origin.

<a id="rainbow.spritebatch:set_texture"></a>
### &lt;rainbow.spritebatch&gt;:set_texture(texture)

<table>
	<tr>
		<td><var>texture</var></td>
		<td>[Texture atlas](#rainbow.texture) used by all [sprites](#rainbow.sprite) in the batch.</td>
	</tr>
</table>

Sets [texture atlas](#rainbow.texture).

<a id="rainbow.stack"></a>
## rainbow.stack

Stack is a last in, first out (LIFO) data type and linear data structure. A stack can store any element but only the top element is available at any time.

	local mystack = rainbow.stack()
	mystack:push(1)  # Stack is now { 1 }
	mystack:push(2)  # Stack is now { 1, 2 }
	mystack:push(3)  # Stack is now { 1, 2, 3 }
	mystack:push(4)  # Stack is now { 1, 2, 3, 4 }

	local value = mystack:top()  # 'value' is 4

	mystack:pop()          # Stack is now { 1, 2, 3 }
	value = mystack:top()  # 'value' is 3
	mystack:pop()          # Stack is now { 1, 2 }
	value = mystack:top()  # 'value' is 2
	mystack:pop()          # Stack is now { 1 }
	value = mystack:top()  # 'value' is 1
	mystack:pop()          # Stack is now empty

<a id="rainbow.stack()"></a>
### rainbow.stack()

Creates a stack.

<a id="rainbow.stack:pop"></a>
### &lt;rainbow.stack&gt;:pop()

Pops an element from the top of the stack.

<a id="rainbow.stack:push"></a>
### &lt;rainbow.stack&gt;:push()

Pushes an element on top of the stack.

<a id="rainbow.stack:top"></a>
### &lt;rainbow.stack&gt;:top()

Returns the element on top of the stack.

<a id="rainbow.texture"></a>
## rainbow.texture

Texture objects are images decoded and sent to the graphics card as texture. Textures are normally stored as raw bitmaps unless they were stored in a compressed format supported by the platform (e.g. ETC1 or PVRTC). This means that a 1024x1024 texture will normally occupy 4MB. In order to save memory, they are assumed to be [atlases](http://en.wikipedia.org/wiki/Texture_atlas) and should be reused whenever possible.

_Note:_ Textures should be square and its sides a power of two (greater than or equal to 64). This is due to how the graphics pipeline works. Even if textures do not meet this recommendation, the graphics drivers will enlarge a texture in order to do so anyway, wasting memory. The maximum size of a texture can be queried in [``rainbow.renderer``](#rainbow.renderer.max_texture_size).

<a id="rainbow.texture()"></a>
### rainbow.texture(path)

<table>
	<tr>
		<td><var>path</var></td>
		<td>Path to texture to load.</td>
	</tr>
</table>

Creates a texture object, usable in [sprite batches](#rainbow.spritebatch).

<a id="rainbow.texture:create"></a>
### &lt;rainbow.texture&gt;:create(x, y, width, height)

<table>
	<tr>
		<td><var>x, y</var></td>
		<td>Upper left point of texture.</td>
	</tr>
	<tr>
		<td><var>width, height</var></td>
		<td>Dimension of texture.</td>
	</tr>
</table>

Creates/defines a texture in the atlas. The unique identifier returned can be used in [sprites](#rainbow.sprite).

<a id="rainbow.timer"></a>
## rainbow.timer

Timers execute a function once after a set time, or any number of times at given intervals.

<a id="rainbow.timer()"></a>
### rainbow.timer(callback, delay, +times)

<table>
	<tr>
		<td><var>callback</var></td>
		<td>The function to call on time-out.</td>
	</tr>
	<tr>
		<td><var>delay</var></td>
		<td>Time in milliseconds to delay call.</td>
	</tr>
	<tr>
		<td><var>times</var></td>
		<td class="optional">Number of times to call. Infinite if omitted.</td>
	</tr>
</table>

Creates a timer.

<a id="rainbow.timer.clear"></a>
### rainbow.timer.clear()

Clears all timers.

<a id="rainbow.timer:cancel"></a>
### &lt;rainbow.timer&gt;:cancel()

Cancels timer.

<a id="rainbow.timer:reset"></a>
### &lt;rainbow.timer&gt;:reset(+delay)

<table>
	<tr>
		<td><var>delay</var></td>
		<td class="optional">Set new delay.</td>
	</tr>
</table>

Resets a timer. Restores it to its initial state.

<a id="rainbow.transition"></a>
## rainbow.transition

<a id="rainbow.transition.clear"></a>
### rainbow.transition.clear()

Cancels all transitions.

<a id="rainbow.transition.fadein"></a>
### rainbow.transition.fadein(source, duration)

<table>
	<tr>
		<td><var>source</var></td>
		<td>The audio channel to fade in.</td>
	</tr>
	<tr>
		<td><var>duration</var></td>
		<td>Duration of the transition in milliseconds.</td>
	</tr>
</table>

Fades in an audio channel.

<a id="rainbow.transition.fadeout"></a>
### rainbow.transition.fadeout(source, duration)

<table>
	<tr>
		<td><var>source</var></td>
		<td>The audio channel to fade out.</td>
	</tr>
	<tr>
		<td><var>duration</var></td>
		<td>Duration of the transition in milliseconds.</td>
	</tr>
</table>

Fades out an audio channel.

<a id="rainbow.transition.fadeto"></a>
### rainbow.transition.fadeto(sprite, alpha, duration, method)

<table>
	<tr>
		<td><var>sprite</var></td>
		<td>The sprite to fade.</td>
	</tr>
	<tr>
		<td><var>alpha</var></td>
		<td>Final alpha value.</td>
	</tr>
	<tr>
		<td><var>duration</var></td>
		<td>Duration of the transition in milliseconds.</td>
	</tr>
	<tr>
		<td><var>method</var></td>
		<td>The equation to use for the transition.</td>
	</tr>
</table>

Fades a sprite to a given alpha value.

<a id="rainbow.transition.move"></a>
### rainbow.transition.move(drawable, x, y, duration, method)

<table>
	<tr>
		<td><var>drawable</var></td>
		<td>An object that implements ``:get_position()`` and ``:move()``.</td>
	</tr>
	<tr>
		<td><var>x, y</var></td>
		<td>Final destination.</td>
	</tr>
	<tr>
		<td><var>duration</var></td>
		<td>Duration of the transition in milliseconds.</td>
	</tr>
	<tr>
		<td><var>method</var></td>
		<td>The equation to use for the transition.</td>
	</tr>
</table>

Moves a drawable to given position.

<a id="rainbow.transition.rotate"></a>
### rainbow.transition.rotate(drawable, r, duration, method)

<table>
	<tr>
		<td><var>drawable</var></td>
		<td>An object that implements ``:get_angle()`` and ``:rotate()``.</td>
	</tr>
	<tr>
		<td><var>r</var></td>
		<td>Final angle.</td>
	</tr>
	<tr>
		<td><var>duration</var></td>
		<td>Duration of the transition in milliseconds.</td>
	</tr>
	<tr>
		<td><var>method</var></td>
		<td>The equation to use for the transition.</td>
	</tr>
</table>

Rotates a drawable to given angle.

<a id="rainbow.transition.scale"></a>
### rainbow.transition.scale(drawable, start, final, duration, method)

<table>
	<tr>
		<td><var>drawable</var></td>
		<td>An object that implements ``:set_scale()``.</td>
	</tr>
	<tr>
		<td><var>start</var></td>
		<td>Start scale factor.</td>
	</tr>
	<tr>
		<td><var>final</var></td>
		<td>Final scale factor.</td>
	</tr>
	<tr>
		<td><var>duration</var></td>
		<td>Duration of the transition in milliseconds.</td>
	</tr>
	<tr>
		<td><var>method</var></td>
		<td>The equation to use for the transition.</td>
	</tr>
</table>

Scales a drawable from a given start factor to a given final factor.

</xmp>
<div id="top"><a href="javascript:window.scroll(0,0);">Top &uarr;</a></div>
<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</body>
</html>
